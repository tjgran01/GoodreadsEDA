import pandas as pd
import numpy as np
import sqlite3
import os
from datetime import datetime
from datetime import timedelta
import sys
# plotting imports
import matplotlib.pyplot as plt
plt.style.use('seaborn-pastel')
import matplotlib.dates as mdates
from dateutil.relativedelta import relativedelta
import seaborn as sns
sns.set_style("ticks")
# my imports
from lists import movie_titl

# Adjust value to change rolling average taken.
n_reviews = 20


def prompt_y_or_n(prompt):
    """Displays a prompts for a user to reply yes or no to, returns the yes or no
    answer as a bool, and rejects invalid input."""

    while True:
        print(prompt)
        ans = input(">")
        if ans[0].upper() == "Y":
            return True
        elif ans[0].upper() == "N":
            return False
        else:
            print("Sorry, that is not a valid answer.")

def get_mv_release(bk, conn):
    """Attempts to find the release date the book to be plotted."""

    try:
        df_rel = pd.read_sql_query(f"""SELECT * FROM Release_Dates
                                       WHERE book_title="{bk}"
                                       ;""", conn)
        return df_rel["release_date"][0]
    except IndexError as e:
        print(f"{e} \n")
        return None


def get_review_score_data(bk, conn):
    """Queries the 'Reviews' table in the db to find the reviews matching the
    book title given as input."""

        df = pd.read_sql_query(f"""SELECT * FROM Reviews
                                   WHERE book_title
                                   LIKE "{bk}%";""", conn)
    return df


def clean_review_data(df, n_reviews):
    """Prepares the DataFrame of review information for plotting by removing
    erroneous information, converting string dates to datetime object, sorting
    the DataFrame date, and dropping rows that do not contain a review score."""

    df.drop(["matching_title", "book_url"], axis=1, inplace=True)
    # turn string dates into datetime objects, and sort the dataframe by date.
    df["review_date"] = pd.to_datetime(df["review_date"])
    df.set_index("review_date", inplace=True)
    df.sort_index(inplace=True)
    # change review scores to ints, if it cannot be converted to int, NaN.
    df["review_score"] = df["review_score"].apply(pd.to_numeric, errors='coerce')
    # drop rows with NaN values in them.
    df.dropna(inplace=True)
    # take rolling average of every fifteen review scores.
    df["review_score_rolling"] = df["review_score"].rolling(window=n_reviews,
                                                            center=False).mean()

    return(df)


def plot_review_data(df, n_reviews, titl, save_files, mv_release=None):
    """Plots a simple line graph of the current review data. If applicable,
    plots the movie release and adjusts the x axis to better fit the timeframe
    of the movie release."""

    x = df.index
    y = df["review_score_rolling"]

    plt.plot(x, y)

    plt.title(f"Review Scores for '{titl}' Over Time.")
    plt.yticks(np.arange(2.5, 5.5, .5))
    plt.ylabel(f"Average Rating Per {n_reviews} Reviews")
    plt.xticks(rotation=45)
    plt.xlabel("Year")
    # If mv_release avilable, plot a solid line to indicate the release date.
    if mv_release:
        mv_release_datetime = datetime.strptime(mv_release, "%d %B %Y")
        plt.axvline(x=mv_release_datetime, color="#f99f75")
        plt.text(mv_release_datetime + timedelta(days=10), 4,
                                                 'Movie Release Date',
                                                 rotation=90,
                                                 color='#767a78')
    # Adjust the plot to be + / - 1 year from movie release.
        plt.xlim(mv_release_datetime - relativedelta(years=1),
                 mv_release_datetime + relativedelta(years=1))
    plt.subplots_adjust(bottom=0.2)
    sns.despine()
    if save_files:
        plt.savefig(f"{os.getcwd()}/../docs/img/{titl}Fig.png", dpi=600)
    plt.show()


def main():
    save_prompt = ("Would you like to save all of the plots generated by "
                    "this script? (Y/n): ")
    save_files = prompt_y_or_n(save_prompt)
    conn = sqlite3.connect(f"{os.getcwd()}/review_dbs/reviews.db")
    for titl in movie_titl:
        df = get_review_score_data(titl, conn)
        df = clean_review_data(df, n_reviews)
        mv_release = get_mv_release(titl, conn)
        plot_review_data(df, n_reviews, titl, save_files, mv_release=mv_release)

    conn.close()


if __name__ == "__main__":
    main()
